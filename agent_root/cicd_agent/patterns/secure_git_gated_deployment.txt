# plan.yaml: A complete pattern definition for a secure CI/CD pipeline.
# This pattern integrates multiple security gates to ensure the integrity and safety of production deployments.

name: "Secure Git-Gated Deployment"
description: "A pattern that enforces security throughout the lifecycle. It includes static code analysis (SAST), container vulnerability scanning, and a Binary Authorization policy to ensure only trusted and verified artifacts are deployed to GKE."

applicability:
  triggers: ["git_commit", "git_tag"]
  deployment_style: "secure_continuous_delivery"
  use_case_keywords: ["security", "compliance", "SLSA", "SAST", "vulnerability scanning", "Binary Authorization"]

# The `resources` section defines the security policy infrastructure.
resources:
  binary_authorization_policy:
    type: "binary-authorization-policy"
    name: "gke-deployment-policy"
    details: "A policy that requires attestations from both the CI system and a vulnerability scanner before allowing deployment to GKE."
    state: "create"
    rules:
      - evaluation_mode: "REQUIRE_ATTESTATION"
        enforcement_mode: "ENFORCED_BLOCK_AND_AUDIT_LOG"
        required_attestors: ["built-by-ci-attestor", "vulnerability-scan-attestor"]

stages:
  # The CI stage now includes a SAST step to find vulnerabilities in source code.
  ci:
    id: "ci_secure_build_and_test"
    type: "cloud-build"
    name: "CI Secure Build and Test"
    details: "Listens for commits. Runs lint, test, and a static analysis security test (SAST) on the source code."
    steps:
      - id: "lint_step"
        type: "linter"
        name: "Run Linter"
        details: "Runs a static code analysis tool."
      - id: "test_step"
        type: "test"
        name: "Run Unit Tests"
        details: "Executes the project's unit test suite."
      - id: "sast_scan_step"
        type: "sast-scanner"
        name: "Static Application Security Testing"
        details: "Scans the source code for security vulnerabilities before building."

  # The CD stage includes vulnerability scanning and requires a Binary Authorization attestation.
  cd:
    trigger:
      type: "git_tag"
      details: "This stage is initiated by pushing a git tag (e.g., v1.3.0)."
    steps:
      - id: "build_and_push_artifact"
        type: "cloud-build"
        name: "Build and Push Release Artifact"
        details: "Builds the final container image and pushes it to Artifact Registry."
      - id: "vulnerability_scan_step"
        type: "artifact-analysis"
        name: "Scan for Vulnerabilities"
        details: "Triggers Artifact Analysis to scan the newly pushed container for known CVEs."
      - id: "create_attestation_step"
        type: "binary-authorization"
        name: "Create Binary Authorization Attestation"
        details: "If the vulnerability scan passes, creates a formal attestation certifying the image is secure and verified."
      - id: "deploy_to_gke_step"
        type: "cloud-deploy"
        name: "Deploy to GKE with Binary Authorization"
        details: "Creates a release in Cloud Deploy to a GKE cluster that has the 'gke-deployment-policy' enforced."

tradeoffs:
  pros:
    - "Provides a high degree of confidence in the security and integrity of deployed artifacts."
    - "Automates security gates, making compliance a part of the standard workflow."
    - "Prevents entire classes of vulnerabilities from reaching production."
  cons:
    - "Increases build time due to additional scanning and analysis steps."
    - "Adds complexity to the pipeline setup and requires careful management of signing keys and attestors."
    - "Can block releases if new, non-critical vulnerabilities are found, requiring a policy tuning process."
